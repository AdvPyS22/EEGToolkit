<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>EEGToolkit.EEGData API documentation</title>
<meta name="description" content="This module provides a data class `EEGData` to work with EEG signal data for event-reaction-time delay experiments.
It works with two separate input â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EEGToolkit.EEGData</code></h1>
</header>
<section id="section-intro">
<p>This module provides a data class <code><a title="EEGToolkit.EEGData.EEGData" href="#EEGToolkit.EEGData.EEGData">EEGData</a></code> to work with EEG signal data for event-reaction-time delay experiments.
It works with two separate input datafiles, one storing the EEG signal itself as a 1D array, and one
describing event metadata as a 2D array, describing both the timepoints and the type of event in two columns.</p>
<p>Supported file types are:
- <code>npy</code>
- <code>txt</code>
( space-separated for events datafiles )
- <code>tsv</code>
- <code>csv</code>
(both <code>,</code> and <code>;</code> separated )
</p>
<h3 id="example-usage">Example Usage</h3>
<p>To use this module for data analysis, only three steps are necessary,
(1st) setup of the <code><a title="EEGToolkit.EEGData.EEGData" href="#EEGToolkit.EEGData.EEGData">EEGData</a></code> object, (2nd) event data extraction, and (3rd)
data summary (which performs signal comparison).</p>
<pre><code># setting up the EEGData with some datafiles
eeg = EEGData( eeg_path = &quot;data/eeg.npy&quot;, event_path = &quot;data/events.npy&quot;, sampling_frequency = 500 )

# extract the events data
data.extract( start_sec = -0.3 , stop_sec = 1 )

# summarize and pair-wise compare event-signal types.
data.summary(
                significance_level = 0.05,
                x_scale = 1000,
                y_scale = 10000,
            )
</code></pre>
<h3 id="cli">CLI</h3>
<p>This module additionally offers a CLI to directly call the full analysis procedure from the terminal.</p>
<pre><code>python3 EEGData.py                     --eeg_path &quot;./data/eeg.npy&quot;                     --event_path &quot;./data/events.npy&quot;                     --sampling_frequency 500                     --p_value 0.05                     --start_sec -0.3                     --stop_sec 1.0                     --x_scale 1000                     --y_scale 10000                     --output &quot;./test_output.pdf&quot;
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

This module provides a data class `EEGData` to work with EEG signal data for event-reaction-time delay experiments.
It works with two separate input datafiles, one storing the EEG signal itself as a 1D array, and one 
describing event metadata as a 2D array, describing both the timepoints and the type of event in two columns.

Supported file types are:
- `npy`
- `txt`     ( space-separated for events datafiles )
- `tsv`
- `csv`     (both `,` and `;` separated )   

### Example Usage
To use this module for data analysis, only three steps are necessary,
(1st) setup of the `EEGData` object, (2nd) event data extraction, and (3rd)
data summary (which performs signal comparison).

```
# setting up the EEGData with some datafiles
eeg = EEGData( eeg_path = &#34;data/eeg.npy&#34;, event_path = &#34;data/events.npy&#34;, sampling_frequency = 500 )

# extract the events data
data.extract( start_sec = -0.3 , stop_sec = 1 )

# summarize and pair-wise compare event-signal types.
data.summary(
                significance_level = 0.05,
                x_scale = 1000,
                y_scale = 10000,
            )
```

### CLI 
This module additionally offers a CLI to directly call the full analysis procedure from the terminal.

```
python3 EEGData.py \
                    --eeg_path &#34;./data/eeg.npy&#34; \
                    --event_path &#34;./data/events.npy&#34; \
                    --sampling_frequency 500 \
                    --p_value 0.05 \
                    --start_sec -0.3 \
                    --stop_sec 1.0 \
                    --x_scale 1000 \
                    --y_scale 10000 \
                    --output &#34;./test_output.pdf&#34;
```

&#34;&#34;&#34;

import os
import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from .EEGStats import plot_signal, difference_plot

supported_filetypes = [ &#34;npy&#34;, &#34;tsv&#34;, &#34;csv&#34;, &#34;txt&#34; ]
class EEGData():
    &#34;&#34;&#34;
    Handles EEG data stored from two separate datafiles, one for the EEG signal
    and one for the corresponding events. 

    Input Datafiles
    --------------
    The EEG signal datafile must be a 1D array of values. 
    The events datafile must be a 2D array of timepoints at which an event occurs,
    as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
    datafiles must **not** contain any headers!

    Supported file types are:
    - `npy`
    - `txt`     ( space-separated for events datafiles )
    - `tsv`
    - `csv`     (both `,` and `;` separated )   

    Parameters
    ----------
    signal_path : str
        A filepath to a valid datafile containing EEG signal data.
    
    event_path : str
        A filepath to a valid datafile containing corresponding 
        event information for the signal datafile.

    sampling_frequency : float
        The frequency at which the EEG was recorded in `Hertz`.

    &#34;&#34;&#34;

    def __init__(self,
                 signal_path:str,
                 event_path:str,
                sampling_frequency:float) -&gt; None:

        # store the used datafiles...
        self._signal_src = signal_path
        self._event_src = event_path

        # first check for valid input data
        self._check_sanity(signal_path, event_path, sampling_frequency)

        # read the datafiles...
        self.read( signal_path = signal_path, event_path = event_path )    

        # now setup the frames for the events 
        self.n_frames = len(self.signal)
        self._set_n_events()

        # setup a _data argument for the 
        # extracted event datasets
        self._data = None 

        # store the frequency
        self.sampling_frequency = sampling_frequency
        
        # setup default parameters for the window around
        # which each event signal should be extracted
        # in seconds
        self._start_sec = -0.5
        self._stop_sec = 1

    def read( self, signal_path : str = None , event_path : str = None ) -&gt; None: 
        &#34;&#34;&#34;
        Read the provided data files and stores the
        data into numpy ndarrays.

        Note
        ----
        This method is automatically called at initiation. However, new data
        can be loaded using this method manually.

        Input Datafiles
        --------------
        The EEG signal datafile must be a 1D array of values. 
        The events datafile must be a 2D array of timepoints at which an event occurs,
        as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
        datafiles must **not** contain any headers!

        Supported file types are:
        - `npy`
        - `txt`     ( space-separated for events datafiles )
        - `tsv`
        - `csv`     (both `,` and `;` separated )   

        Parameters
        ----------
        signal_path : str
            A filepath to a valid datafile containing EEG signal data.
        
        event_path : str
            A filepath to a valid datafile containing corresponding 
            event information for the signal datafile.

        &#34;&#34;&#34;
        
        # first read the signal data file
        if signal_path is not None:
            suffix = self._filesuffix( signal_path )
            if suffix == &#34;npy&#34;: 
                signal = self._read_npy( signal_path )
            else: 
                signal = self._read_datafile( signal_path )

            # now save
            self.signal = signal

        # now the same for the events data file 
        if event_path is not None: 
            suffix = self._filesuffix( event_path )
            if suffix == &#34;npy&#34;: 
                events = self._read_npy( event_path )
            else: 
                events = self._read_datafile( event_path )

            # now save
            self.events = events


    def extract(self,
                start_sec:float,
                stop_sec:float,
                event_type : ( int or tuple or list or np.ndarray ) = None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Extracts data for a specific (set of) event(s) from the loaded data. 
        And returns the data as numpy ndarrays (or a list thereof, in case of 
        multiple events).

        Note
        ----
        This method is automatically called by `EGGData.summary` so it is not necessary
        to manually extract data, unless only a specific subset of event types should
        be extracted!

        Parameters
        ----------
        start_sec : float
            The timepoint relative to the provided 
            events data in seconds at which to begin extraction. 
            E.g. `-0.05` would correspond to `0.05 seconds` before
            the actual onset of the recorded event.

        stop_sec : float
            The timepoint relative to the provided 
            events data in seconds at which to end extraction. 
            E.g. `0.75` would correspond to `0.75 seconds` after
            the actual onset of the recorded event.
        
        event_type : int or tuple or list or np.ndarray
            Either a single event type or an iterable of multiple event types.
            If `event_type = None` (default) data for **all** event types will be extracted!

        Returns
        -------
        extracted_data : np.ndarray or list
            The data of the provided events as an ndarray or a 
            list of ndarrays in the same order as the provided event-type labels.
        &#34;&#34;&#34;

        # check if we should extract the data for all events
        if event_type is None:

            # get all events
            events_to_extract = self.n_events.keys()

            # extract each type from the loaded data
            data = [ 
                        self.extract(start_sec, stop_sec, etype) 
                        for etype in events_to_extract 
                ]

            self._data = data
            return data

        # check if there is a provided subset of events to extract
        if isinstance(event_type, (tuple, np.ndarray, list)):

            events_to_extract = event_type

            # extract provided type from the loaded data
            data = [ 
                        self.extract(start_sec, stop_sec, etype) 
                        for etype in events_to_extract 
                ]

            self._data = data
            return data

        # now the part for extracting only a 
        # single event type data
        
        # first adjust the start and end to 
        # match the sampling frequency 
        start_frame = int( start_sec * self.sampling_frequency )
        stop_frame = int( stop_sec * self.sampling_frequency )

        # next generate a set of slices for the EEG data around the timepoints for
        # the events
        firing_slices = [
                            slice( event[0]+start_frame, event[0]+stop_frame ) 
                            for event in self.events 
                            if event[1] == event_type
                    ]

        # now get the actual data of the event
        data = [ self.signal[ slice ] for slice in firing_slices ]
        data = np.array( data )

        self._data = data

        # store start and stop sec values
        # for later use in summary()
        self._start_sec = start_sec
        self._stop_sec = stop_sec

        return data

    def summary(self,
                x_scale:float,
                y_scale:float,
                significance_level:float = 0.05,
                output:str = None,
                **kwargs ) -&gt; None:
        &#34;&#34;&#34;
        Performs pair-wise T-Tests to compare extracted event data 
        (automatically extracts data for all events if no events were extracted yet). 
        Results are summarised in a figure. Individual signals are plotted
        on the diagonal by their mean signal accross replicates with indicated SEM.
        On non-diagonal plots pair-wise comparisons between two signals (one &#34;horizontal&#34;
        and one &#34;vertical&#34; ) are shown. Regions of significant differences are shaded.

        Parameters
        ----------

        x_scale : float
            A scaling factor to adjust the data&#39;s x-value range. 
            E.g. `x_scale = 1000` to adjust the time-scale to milliseconds.
        
        y_scale : float
            A scaling factor for the data&#39;s y-value range.
            E.g. `y_scale = 1000` to adjust the signal-scale to millivolts.

        significance_level : float
            The threshold for accepting a signal difference as significant.
            Default is `0.05`.
        
        output : str
            The output filename to save the summary figure into.

        **kwargs
            Any additional keyword arguments to pass to `EEGData.extract` in case
            no event data has been extracted yet.
        &#34;&#34;&#34;

        # extract the event data if not yet done already
        if self._data is None: 

            start_sec = kwargs.pop( &#34;start_sec&#34;, self._start_sec )
            stop_sec = kwargs.pop( &#34;stop_sec&#34;, self._stop_sec )
            self.extract( start_sec = start_sec, stop_sec = stop_sec, **kwargs )

        data = list( self._data ) 
        signals = list(self.n_events.keys())
        n = len(data)

        start_sec, stop_sec = self._start_sec, self._stop_sec

        # generate a new figure
        fig, ax = plt.subplots(n,n)

        # now first plot the individual signals
        # on their own on diagonal plots
        for i in range(n):

            # only the last subplot should make a legend
            make_legend = i == n-1 
            plot_signal(
                    data[i], 
                    self.sampling_frequency, 
                    start_sec, stop_sec, 
                    x_scale, y_scale,
                    make_legend = make_legend,
                    ax = ax[i,i] )
                
            ax[i,i].set_title(f&#34;Signal {signals[i]}&#34;)

            # hide all &#34;left-over&#34; subplots from the layout
            # i.e. hide the upper-right half of the figure...
            for a in ax[ i, i+1: ]:
                a.axis(&#34;off&#34;)

        # now make pair-wise comparisons between two signals
        # plotting the results on the lower-left half of the 
        # figure...
        for i,j in [(i,j) for i in range(n) for j in range(i)]:

            # only the last plot shall make a legend
            make_legend = i == n-1 and j == i-1 

            difference_plot( 
                                data[i], 
                                data[j], 
                                self.sampling_frequency, 
                                start_sec, stop_sec, 
                                significance_level, 
                                x_scale, y_scale,
                                make_legend = make_legend,
                                ax = ax[i,j]
                            )
            ax[i,j].set_title(f&#34;Signals: {signals[j]} vs {signals[i]}&#34;)

        fig.tight_layout()
        
        if output is None:
            plt.show()
            return fig
        plt.savefig(output, bbox_inches = &#34;tight&#34; )

    def _set_n_events(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up a dictionary of the different event types
        found in the events data.
        &#34;&#34;&#34;

        event_types = {event[1] for event in self.events}
        self.n_events = {event_type: len([event for event in self.events if event[1] == event_type]) for event_type in event_types}            

    def _check_sanity(self, signal_path, event_path, sampling_frequency):
        &#34;&#34;&#34;
        Checks if valid data inputs were provided
        &#34;&#34;&#34;

        # check if input files exist
        if not os.path.isfile(signal_path):
            raise FileNotFoundError( f&#34;The signal datafile could not be found at &#39;{signal_path}&#39;!&#34; )
        
        if not os.path.isfile(event_path):
            raise FileNotFoundError( f&#34;The event datafile could not be found at &#39;{event_path}!&#34; )
        
        # check if the datafiles conform to suppored filetypes
        fname = os.path.basename(signal_path)
        if not any( [ fname.endswith(suffix) for suffix in supported_filetypes ] ):
            suffix = fname.split(&#34;.&#34;)[-1]
            raise TypeError( f&#34;The signal datafile could not be interpreted (&#39;.{suffix}&#39;), only {supported_filetypes} files are supported!&#34; )

        fname = os.path.basename(event_path)
        if not any( [ fname.endswith(suffix) for suffix in supported_filetypes ] ):
            suffix = fname.split(&#34;.&#34;)[-1]
            raise TypeError( f&#34;The event datafile could not be interpreted (&#39;.{suffix}&#39;), only {supported_filetypes} files are supported!&#34; )
        
        # check if the frequency is a positive number
        if not sampling_frequency &gt; 0:
            raise ValueError( f&#34;Sampling frequency {sampling_frequency} must be a positive value&#34; )

    def _read_npy( self, filepath ) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Reads data from npy files
        &#34;&#34;&#34;
        data = np.load(filepath)
        return data 

    def _read_datafile( self, filepath) -&gt; np.ndarray: 
        &#34;&#34;&#34;
        Reads data from tsv, csv, and txt files
        &#34;&#34;&#34;

        # first get the filetype 
        suffix = self._filesuffix(filepath)

        # now get the corresponding delimiter
        delimiters = {
                        &#34;csv&#34; : self._csv_delimiter( filepath ),
                        &#34;tsv&#34; : &#34;\t&#34;,
                        &#34;txt&#34; : &#34; &#34;
                    }
        delimiter = delimiters[ suffix ]
        
        # now read the file
        data = pd.read_csv( filepath, header = None, sep = delimiter )

        # convert to numpy ndarray
        data = data.to_numpy()
        data = np.squeeze( data )
        return data 

    def _filesuffix(self, filepath):
        &#34;&#34;&#34;
        Returns the suffix from a filepath
        &#34;&#34;&#34;
        suffix = os.path.basename( filepath )
        suffix = suffix.split(&#34;.&#34;)[-1]
        return suffix

    def _csv_delimiter(self, filepath):
        &#34;&#34;&#34;
        Checks if a csv file is , or ; delimited and returns the 
        correct delmiter to use...
        &#34;&#34;&#34;
        # open the file and read 
        with open( filepath, &#34;r&#34; ) as f:
            content = f.read()

        # check if a semicolon is present
        # if so, we delimit at ; 
        has_semicolon = &#34;;&#34; in content
        delimiter = &#34;;&#34; if has_semicolon else &#34;,&#34;

        return delimiter

def main():
    &#34;&#34;&#34;
    The main function called through the CLI

    Example Usage
    -------------
    python3 ./EEGToolkit/EEGData.py \
        --eeg_path &#34;data/eeg.npy&#34; \
        --event_path &#34;data/events.npy&#34; \
        --sampling_frequency 500 \
        --p_value 0.05 \
        --start_sec -0.3 \
        --stop_sec 1.0 \
        --x_scale 1000 \
        --y_scale 1000 \
        --output &#34;./test.png&#34;
    &#34;&#34;&#34;

    parser = argparse.ArgumentParser(prefix_chars=&#39;-&#39;)
    parser.add_argument(
                            &#34;--eeg_path&#34;, &#34;--eeg&#34;, 
                            type=str, required=True, 
                            help = f&#34;A file containing EEG signal data. Supported filetypes are {supported_filetypes}&#34; 
                    )
    parser.add_argument(
                            &#34;--event_path&#34;, &#34;--event&#34;, 
                            type=str, required=True,
                            help = &#34;A file containing event metadata for the signal file. Supported filetypes are {supported_filetypes}&#34;
                    )
    parser.add_argument(
                            &#34;--output&#34;, &#34;-o&#34;, 
                            type=str, default = None,
                            help = &#34;An output file into which the output summary figure should be saved. If none is provided (default) the Figure will simply be shown.&#34;
                    )
    parser.add_argument(
                            &#34;--sampling_frequency&#34;, &#34;--freq&#34;, &#34;-f&#34;, 
                            type=float, required=True,
                            help = &#34;The frequency at which the EEG signal data was recorded (in Hertz).&#34;
                    )
    parser.add_argument(
                            &#34;--p_value&#34;, &#34;-p&#34;, 
                            type=float, default = 0.05, 
                            help = &#34;The significance threshold at which to accept two signals being significantly different at a T-Test comparison. Default is 0.05.&#34;
                    )
    parser.add_argument(
                            &#34;--start_sec&#34;, &#34;--start&#34;, &#34;-s&#34;, 
                            type=float, required=True,
                            help = &#34;The upstream time-padding for event extraction (in seconds).&#34;
                    )
    parser.add_argument(
                            &#34;--stop_sec&#34;, &#34;--stop&#34;, &#34;-e&#34;, 
                            type=float, required=True,
                            help = &#34;The downstream time-padding for event extraction (in seconds).&#34;
                    )
    parser.add_argument(
                            &#34;--x_scale&#34;, &#34;-x&#34;, 
                            type=float, default = 1000,
                            help = &#34;A scaling factor for the time-scale (x-values) from seconds to some other unit. Default is 1000 (= milliseconds).&#34;
                    )
    parser.add_argument(
                            &#34;--y_scale&#34;, &#34;-y&#34;, 
                            type=float, default = 1000,
                            help = &#34;A scaling factor for the signal-scale (y-values) from volts to some other unit. Default is 1000 (= millivolts).&#34;
                    )

    args = parser.parse_args()
    
    # the main program (reading datafiles, extracting, and summarizing)
    data = EEGData(args.eeg_path, args.event_path, args.sampling_frequency)
    data.extract( args.start_sec, args.stop_sec )
    data.summary(
                    significance_level = args.p_value,
                    x_scale = args.x_scale,
                    y_scale = args.y_scale,
                    output = args.output
                )

    if args.output is not None: 
        print( f&#34;Output saved successfully to: &#39;{args.output}&#39;&#34; ) 

if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="EEGToolkit.EEGData.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The main function called through the CLI</p>
<h2 id="example-usage">Example Usage</h2>
<p>python3 ./EEGToolkit/EEGData.py
&ndash;eeg_path "data/eeg.npy"
&ndash;event_path "data/events.npy"
&ndash;sampling_frequency 500
&ndash;p_value 0.05
&ndash;start_sec -0.3
&ndash;stop_sec 1.0
&ndash;x_scale 1000
&ndash;y_scale 1000
&ndash;output "./test.png"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    The main function called through the CLI

    Example Usage
    -------------
    python3 ./EEGToolkit/EEGData.py \
        --eeg_path &#34;data/eeg.npy&#34; \
        --event_path &#34;data/events.npy&#34; \
        --sampling_frequency 500 \
        --p_value 0.05 \
        --start_sec -0.3 \
        --stop_sec 1.0 \
        --x_scale 1000 \
        --y_scale 1000 \
        --output &#34;./test.png&#34;
    &#34;&#34;&#34;

    parser = argparse.ArgumentParser(prefix_chars=&#39;-&#39;)
    parser.add_argument(
                            &#34;--eeg_path&#34;, &#34;--eeg&#34;, 
                            type=str, required=True, 
                            help = f&#34;A file containing EEG signal data. Supported filetypes are {supported_filetypes}&#34; 
                    )
    parser.add_argument(
                            &#34;--event_path&#34;, &#34;--event&#34;, 
                            type=str, required=True,
                            help = &#34;A file containing event metadata for the signal file. Supported filetypes are {supported_filetypes}&#34;
                    )
    parser.add_argument(
                            &#34;--output&#34;, &#34;-o&#34;, 
                            type=str, default = None,
                            help = &#34;An output file into which the output summary figure should be saved. If none is provided (default) the Figure will simply be shown.&#34;
                    )
    parser.add_argument(
                            &#34;--sampling_frequency&#34;, &#34;--freq&#34;, &#34;-f&#34;, 
                            type=float, required=True,
                            help = &#34;The frequency at which the EEG signal data was recorded (in Hertz).&#34;
                    )
    parser.add_argument(
                            &#34;--p_value&#34;, &#34;-p&#34;, 
                            type=float, default = 0.05, 
                            help = &#34;The significance threshold at which to accept two signals being significantly different at a T-Test comparison. Default is 0.05.&#34;
                    )
    parser.add_argument(
                            &#34;--start_sec&#34;, &#34;--start&#34;, &#34;-s&#34;, 
                            type=float, required=True,
                            help = &#34;The upstream time-padding for event extraction (in seconds).&#34;
                    )
    parser.add_argument(
                            &#34;--stop_sec&#34;, &#34;--stop&#34;, &#34;-e&#34;, 
                            type=float, required=True,
                            help = &#34;The downstream time-padding for event extraction (in seconds).&#34;
                    )
    parser.add_argument(
                            &#34;--x_scale&#34;, &#34;-x&#34;, 
                            type=float, default = 1000,
                            help = &#34;A scaling factor for the time-scale (x-values) from seconds to some other unit. Default is 1000 (= milliseconds).&#34;
                    )
    parser.add_argument(
                            &#34;--y_scale&#34;, &#34;-y&#34;, 
                            type=float, default = 1000,
                            help = &#34;A scaling factor for the signal-scale (y-values) from volts to some other unit. Default is 1000 (= millivolts).&#34;
                    )

    args = parser.parse_args()
    
    # the main program (reading datafiles, extracting, and summarizing)
    data = EEGData(args.eeg_path, args.event_path, args.sampling_frequency)
    data.extract( args.start_sec, args.stop_sec )
    data.summary(
                    significance_level = args.p_value,
                    x_scale = args.x_scale,
                    y_scale = args.y_scale,
                    output = args.output
                )

    if args.output is not None: 
        print( f&#34;Output saved successfully to: &#39;{args.output}&#39;&#34; ) </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="EEGToolkit.EEGData.EEGData"><code class="flex name class">
<span>class <span class="ident">EEGData</span></span>
<span>(</span><span>signal_path:Â str, event_path:Â str, sampling_frequency:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles EEG data stored from two separate datafiles, one for the EEG signal
and one for the corresponding events. </p>
<h2 id="input-datafiles">Input Datafiles</h2>
<p>The EEG signal datafile must be a 1D array of values.
The events datafile must be a 2D array of timepoints at which an event occurs,
as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
datafiles must <strong>not</strong> contain any headers!</p>
<p>Supported file types are:
- <code>npy</code>
- <code>txt</code>
( space-separated for events datafiles )
- <code>tsv</code>
- <code>csv</code>
(both <code>,</code> and <code>;</code> separated )
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal_path</code></strong> :&ensp;<code>str</code></dt>
<dd>A filepath to a valid datafile containing EEG signal data.</dd>
<dt><strong><code>event_path</code></strong> :&ensp;<code>str</code></dt>
<dd>A filepath to a valid datafile containing corresponding
event information for the signal datafile.</dd>
<dt><strong><code>sampling_frequency</code></strong> :&ensp;<code>float</code></dt>
<dd>The frequency at which the EEG was recorded in <code>Hertz</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EEGData():
    &#34;&#34;&#34;
    Handles EEG data stored from two separate datafiles, one for the EEG signal
    and one for the corresponding events. 

    Input Datafiles
    --------------
    The EEG signal datafile must be a 1D array of values. 
    The events datafile must be a 2D array of timepoints at which an event occurs,
    as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
    datafiles must **not** contain any headers!

    Supported file types are:
    - `npy`
    - `txt`     ( space-separated for events datafiles )
    - `tsv`
    - `csv`     (both `,` and `;` separated )   

    Parameters
    ----------
    signal_path : str
        A filepath to a valid datafile containing EEG signal data.
    
    event_path : str
        A filepath to a valid datafile containing corresponding 
        event information for the signal datafile.

    sampling_frequency : float
        The frequency at which the EEG was recorded in `Hertz`.

    &#34;&#34;&#34;

    def __init__(self,
                 signal_path:str,
                 event_path:str,
                sampling_frequency:float) -&gt; None:

        # store the used datafiles...
        self._signal_src = signal_path
        self._event_src = event_path

        # first check for valid input data
        self._check_sanity(signal_path, event_path, sampling_frequency)

        # read the datafiles...
        self.read( signal_path = signal_path, event_path = event_path )    

        # now setup the frames for the events 
        self.n_frames = len(self.signal)
        self._set_n_events()

        # setup a _data argument for the 
        # extracted event datasets
        self._data = None 

        # store the frequency
        self.sampling_frequency = sampling_frequency
        
        # setup default parameters for the window around
        # which each event signal should be extracted
        # in seconds
        self._start_sec = -0.5
        self._stop_sec = 1

    def read( self, signal_path : str = None , event_path : str = None ) -&gt; None: 
        &#34;&#34;&#34;
        Read the provided data files and stores the
        data into numpy ndarrays.

        Note
        ----
        This method is automatically called at initiation. However, new data
        can be loaded using this method manually.

        Input Datafiles
        --------------
        The EEG signal datafile must be a 1D array of values. 
        The events datafile must be a 2D array of timepoints at which an event occurs,
        as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
        datafiles must **not** contain any headers!

        Supported file types are:
        - `npy`
        - `txt`     ( space-separated for events datafiles )
        - `tsv`
        - `csv`     (both `,` and `;` separated )   

        Parameters
        ----------
        signal_path : str
            A filepath to a valid datafile containing EEG signal data.
        
        event_path : str
            A filepath to a valid datafile containing corresponding 
            event information for the signal datafile.

        &#34;&#34;&#34;
        
        # first read the signal data file
        if signal_path is not None:
            suffix = self._filesuffix( signal_path )
            if suffix == &#34;npy&#34;: 
                signal = self._read_npy( signal_path )
            else: 
                signal = self._read_datafile( signal_path )

            # now save
            self.signal = signal

        # now the same for the events data file 
        if event_path is not None: 
            suffix = self._filesuffix( event_path )
            if suffix == &#34;npy&#34;: 
                events = self._read_npy( event_path )
            else: 
                events = self._read_datafile( event_path )

            # now save
            self.events = events


    def extract(self,
                start_sec:float,
                stop_sec:float,
                event_type : ( int or tuple or list or np.ndarray ) = None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Extracts data for a specific (set of) event(s) from the loaded data. 
        And returns the data as numpy ndarrays (or a list thereof, in case of 
        multiple events).

        Note
        ----
        This method is automatically called by `EGGData.summary` so it is not necessary
        to manually extract data, unless only a specific subset of event types should
        be extracted!

        Parameters
        ----------
        start_sec : float
            The timepoint relative to the provided 
            events data in seconds at which to begin extraction. 
            E.g. `-0.05` would correspond to `0.05 seconds` before
            the actual onset of the recorded event.

        stop_sec : float
            The timepoint relative to the provided 
            events data in seconds at which to end extraction. 
            E.g. `0.75` would correspond to `0.75 seconds` after
            the actual onset of the recorded event.
        
        event_type : int or tuple or list or np.ndarray
            Either a single event type or an iterable of multiple event types.
            If `event_type = None` (default) data for **all** event types will be extracted!

        Returns
        -------
        extracted_data : np.ndarray or list
            The data of the provided events as an ndarray or a 
            list of ndarrays in the same order as the provided event-type labels.
        &#34;&#34;&#34;

        # check if we should extract the data for all events
        if event_type is None:

            # get all events
            events_to_extract = self.n_events.keys()

            # extract each type from the loaded data
            data = [ 
                        self.extract(start_sec, stop_sec, etype) 
                        for etype in events_to_extract 
                ]

            self._data = data
            return data

        # check if there is a provided subset of events to extract
        if isinstance(event_type, (tuple, np.ndarray, list)):

            events_to_extract = event_type

            # extract provided type from the loaded data
            data = [ 
                        self.extract(start_sec, stop_sec, etype) 
                        for etype in events_to_extract 
                ]

            self._data = data
            return data

        # now the part for extracting only a 
        # single event type data
        
        # first adjust the start and end to 
        # match the sampling frequency 
        start_frame = int( start_sec * self.sampling_frequency )
        stop_frame = int( stop_sec * self.sampling_frequency )

        # next generate a set of slices for the EEG data around the timepoints for
        # the events
        firing_slices = [
                            slice( event[0]+start_frame, event[0]+stop_frame ) 
                            for event in self.events 
                            if event[1] == event_type
                    ]

        # now get the actual data of the event
        data = [ self.signal[ slice ] for slice in firing_slices ]
        data = np.array( data )

        self._data = data

        # store start and stop sec values
        # for later use in summary()
        self._start_sec = start_sec
        self._stop_sec = stop_sec

        return data

    def summary(self,
                x_scale:float,
                y_scale:float,
                significance_level:float = 0.05,
                output:str = None,
                **kwargs ) -&gt; None:
        &#34;&#34;&#34;
        Performs pair-wise T-Tests to compare extracted event data 
        (automatically extracts data for all events if no events were extracted yet). 
        Results are summarised in a figure. Individual signals are plotted
        on the diagonal by their mean signal accross replicates with indicated SEM.
        On non-diagonal plots pair-wise comparisons between two signals (one &#34;horizontal&#34;
        and one &#34;vertical&#34; ) are shown. Regions of significant differences are shaded.

        Parameters
        ----------

        x_scale : float
            A scaling factor to adjust the data&#39;s x-value range. 
            E.g. `x_scale = 1000` to adjust the time-scale to milliseconds.
        
        y_scale : float
            A scaling factor for the data&#39;s y-value range.
            E.g. `y_scale = 1000` to adjust the signal-scale to millivolts.

        significance_level : float
            The threshold for accepting a signal difference as significant.
            Default is `0.05`.
        
        output : str
            The output filename to save the summary figure into.

        **kwargs
            Any additional keyword arguments to pass to `EEGData.extract` in case
            no event data has been extracted yet.
        &#34;&#34;&#34;

        # extract the event data if not yet done already
        if self._data is None: 

            start_sec = kwargs.pop( &#34;start_sec&#34;, self._start_sec )
            stop_sec = kwargs.pop( &#34;stop_sec&#34;, self._stop_sec )
            self.extract( start_sec = start_sec, stop_sec = stop_sec, **kwargs )

        data = list( self._data ) 
        signals = list(self.n_events.keys())
        n = len(data)

        start_sec, stop_sec = self._start_sec, self._stop_sec

        # generate a new figure
        fig, ax = plt.subplots(n,n)

        # now first plot the individual signals
        # on their own on diagonal plots
        for i in range(n):

            # only the last subplot should make a legend
            make_legend = i == n-1 
            plot_signal(
                    data[i], 
                    self.sampling_frequency, 
                    start_sec, stop_sec, 
                    x_scale, y_scale,
                    make_legend = make_legend,
                    ax = ax[i,i] )
                
            ax[i,i].set_title(f&#34;Signal {signals[i]}&#34;)

            # hide all &#34;left-over&#34; subplots from the layout
            # i.e. hide the upper-right half of the figure...
            for a in ax[ i, i+1: ]:
                a.axis(&#34;off&#34;)

        # now make pair-wise comparisons between two signals
        # plotting the results on the lower-left half of the 
        # figure...
        for i,j in [(i,j) for i in range(n) for j in range(i)]:

            # only the last plot shall make a legend
            make_legend = i == n-1 and j == i-1 

            difference_plot( 
                                data[i], 
                                data[j], 
                                self.sampling_frequency, 
                                start_sec, stop_sec, 
                                significance_level, 
                                x_scale, y_scale,
                                make_legend = make_legend,
                                ax = ax[i,j]
                            )
            ax[i,j].set_title(f&#34;Signals: {signals[j]} vs {signals[i]}&#34;)

        fig.tight_layout()
        
        if output is None:
            plt.show()
            return fig
        plt.savefig(output, bbox_inches = &#34;tight&#34; )

    def _set_n_events(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up a dictionary of the different event types
        found in the events data.
        &#34;&#34;&#34;

        event_types = {event[1] for event in self.events}
        self.n_events = {event_type: len([event for event in self.events if event[1] == event_type]) for event_type in event_types}            

    def _check_sanity(self, signal_path, event_path, sampling_frequency):
        &#34;&#34;&#34;
        Checks if valid data inputs were provided
        &#34;&#34;&#34;

        # check if input files exist
        if not os.path.isfile(signal_path):
            raise FileNotFoundError( f&#34;The signal datafile could not be found at &#39;{signal_path}&#39;!&#34; )
        
        if not os.path.isfile(event_path):
            raise FileNotFoundError( f&#34;The event datafile could not be found at &#39;{event_path}!&#34; )
        
        # check if the datafiles conform to suppored filetypes
        fname = os.path.basename(signal_path)
        if not any( [ fname.endswith(suffix) for suffix in supported_filetypes ] ):
            suffix = fname.split(&#34;.&#34;)[-1]
            raise TypeError( f&#34;The signal datafile could not be interpreted (&#39;.{suffix}&#39;), only {supported_filetypes} files are supported!&#34; )

        fname = os.path.basename(event_path)
        if not any( [ fname.endswith(suffix) for suffix in supported_filetypes ] ):
            suffix = fname.split(&#34;.&#34;)[-1]
            raise TypeError( f&#34;The event datafile could not be interpreted (&#39;.{suffix}&#39;), only {supported_filetypes} files are supported!&#34; )
        
        # check if the frequency is a positive number
        if not sampling_frequency &gt; 0:
            raise ValueError( f&#34;Sampling frequency {sampling_frequency} must be a positive value&#34; )

    def _read_npy( self, filepath ) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Reads data from npy files
        &#34;&#34;&#34;
        data = np.load(filepath)
        return data 

    def _read_datafile( self, filepath) -&gt; np.ndarray: 
        &#34;&#34;&#34;
        Reads data from tsv, csv, and txt files
        &#34;&#34;&#34;

        # first get the filetype 
        suffix = self._filesuffix(filepath)

        # now get the corresponding delimiter
        delimiters = {
                        &#34;csv&#34; : self._csv_delimiter( filepath ),
                        &#34;tsv&#34; : &#34;\t&#34;,
                        &#34;txt&#34; : &#34; &#34;
                    }
        delimiter = delimiters[ suffix ]
        
        # now read the file
        data = pd.read_csv( filepath, header = None, sep = delimiter )

        # convert to numpy ndarray
        data = data.to_numpy()
        data = np.squeeze( data )
        return data 

    def _filesuffix(self, filepath):
        &#34;&#34;&#34;
        Returns the suffix from a filepath
        &#34;&#34;&#34;
        suffix = os.path.basename( filepath )
        suffix = suffix.split(&#34;.&#34;)[-1]
        return suffix

    def _csv_delimiter(self, filepath):
        &#34;&#34;&#34;
        Checks if a csv file is , or ; delimited and returns the 
        correct delmiter to use...
        &#34;&#34;&#34;
        # open the file and read 
        with open( filepath, &#34;r&#34; ) as f:
            content = f.read()

        # check if a semicolon is present
        # if so, we delimit at ; 
        has_semicolon = &#34;;&#34; in content
        delimiter = &#34;;&#34; if has_semicolon else &#34;,&#34;

        return delimiter</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EEGToolkit.EEGData.EEGData.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, start_sec:Â float, stop_sec:Â float, event_type:Â intÂ =Â None) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts data for a specific (set of) event(s) from the loaded data.
And returns the data as numpy ndarrays (or a list thereof, in case of
multiple events).</p>
<h2 id="note">Note</h2>
<p>This method is automatically called by <code>EGGData.summary</code> so it is not necessary
to manually extract data, unless only a specific subset of event types should
be extracted!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>The timepoint relative to the provided
events data in seconds at which to begin extraction.
E.g. <code>-0.05</code> would correspond to <code>0.05 seconds</code> before
the actual onset of the recorded event.</dd>
<dt><strong><code>stop_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>The timepoint relative to the provided
events data in seconds at which to end extraction.
E.g. <code>0.75</code> would correspond to <code>0.75 seconds</code> after
the actual onset of the recorded event.</dd>
<dt><strong><code>event_type</code></strong> :&ensp;<code>int</code> or <code>tuple</code> or <code>list</code> or <code>np.ndarray</code></dt>
<dd>Either a single event type or an iterable of multiple event types.
If <code>event_type = None</code> (default) data for <strong>all</strong> event types will be extracted!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>extracted_data</code></strong> :&ensp;<code>np.ndarray</code> or <code>list</code></dt>
<dd>The data of the provided events as an ndarray or a
list of ndarrays in the same order as the provided event-type labels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self,
            start_sec:float,
            stop_sec:float,
            event_type : ( int or tuple or list or np.ndarray ) = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Extracts data for a specific (set of) event(s) from the loaded data. 
    And returns the data as numpy ndarrays (or a list thereof, in case of 
    multiple events).

    Note
    ----
    This method is automatically called by `EGGData.summary` so it is not necessary
    to manually extract data, unless only a specific subset of event types should
    be extracted!

    Parameters
    ----------
    start_sec : float
        The timepoint relative to the provided 
        events data in seconds at which to begin extraction. 
        E.g. `-0.05` would correspond to `0.05 seconds` before
        the actual onset of the recorded event.

    stop_sec : float
        The timepoint relative to the provided 
        events data in seconds at which to end extraction. 
        E.g. `0.75` would correspond to `0.75 seconds` after
        the actual onset of the recorded event.
    
    event_type : int or tuple or list or np.ndarray
        Either a single event type or an iterable of multiple event types.
        If `event_type = None` (default) data for **all** event types will be extracted!

    Returns
    -------
    extracted_data : np.ndarray or list
        The data of the provided events as an ndarray or a 
        list of ndarrays in the same order as the provided event-type labels.
    &#34;&#34;&#34;

    # check if we should extract the data for all events
    if event_type is None:

        # get all events
        events_to_extract = self.n_events.keys()

        # extract each type from the loaded data
        data = [ 
                    self.extract(start_sec, stop_sec, etype) 
                    for etype in events_to_extract 
            ]

        self._data = data
        return data

    # check if there is a provided subset of events to extract
    if isinstance(event_type, (tuple, np.ndarray, list)):

        events_to_extract = event_type

        # extract provided type from the loaded data
        data = [ 
                    self.extract(start_sec, stop_sec, etype) 
                    for etype in events_to_extract 
            ]

        self._data = data
        return data

    # now the part for extracting only a 
    # single event type data
    
    # first adjust the start and end to 
    # match the sampling frequency 
    start_frame = int( start_sec * self.sampling_frequency )
    stop_frame = int( stop_sec * self.sampling_frequency )

    # next generate a set of slices for the EEG data around the timepoints for
    # the events
    firing_slices = [
                        slice( event[0]+start_frame, event[0]+stop_frame ) 
                        for event in self.events 
                        if event[1] == event_type
                ]

    # now get the actual data of the event
    data = [ self.signal[ slice ] for slice in firing_slices ]
    data = np.array( data )

    self._data = data

    # store start and stop sec values
    # for later use in summary()
    self._start_sec = start_sec
    self._stop_sec = stop_sec

    return data</code></pre>
</details>
</dd>
<dt id="EEGToolkit.EEGData.EEGData.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, signal_path:Â strÂ =Â None, event_path:Â strÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Read the provided data files and stores the
data into numpy ndarrays.</p>
<h2 id="note">Note</h2>
<p>This method is automatically called at initiation. However, new data
can be loaded using this method manually.</p>
<h2 id="input-datafiles">Input Datafiles</h2>
<p>The EEG signal datafile must be a 1D array of values.
The events datafile must be a 2D array of timepoints at which an event occurs,
as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
datafiles must <strong>not</strong> contain any headers!</p>
<p>Supported file types are:
- <code>npy</code>
- <code>txt</code>
( space-separated for events datafiles )
- <code>tsv</code>
- <code>csv</code>
(both <code>,</code> and <code>;</code> separated )
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal_path</code></strong> :&ensp;<code>str</code></dt>
<dd>A filepath to a valid datafile containing EEG signal data.</dd>
<dt><strong><code>event_path</code></strong> :&ensp;<code>str</code></dt>
<dd>A filepath to a valid datafile containing corresponding
event information for the signal datafile.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read( self, signal_path : str = None , event_path : str = None ) -&gt; None: 
    &#34;&#34;&#34;
    Read the provided data files and stores the
    data into numpy ndarrays.

    Note
    ----
    This method is automatically called at initiation. However, new data
    can be loaded using this method manually.

    Input Datafiles
    --------------
    The EEG signal datafile must be a 1D array of values. 
    The events datafile must be a 2D array of timepoints at which an event occurs,
    as well as a categorical (numerically encoded) label of the kind of event that occured. Note, that the
    datafiles must **not** contain any headers!

    Supported file types are:
    - `npy`
    - `txt`     ( space-separated for events datafiles )
    - `tsv`
    - `csv`     (both `,` and `;` separated )   

    Parameters
    ----------
    signal_path : str
        A filepath to a valid datafile containing EEG signal data.
    
    event_path : str
        A filepath to a valid datafile containing corresponding 
        event information for the signal datafile.

    &#34;&#34;&#34;
    
    # first read the signal data file
    if signal_path is not None:
        suffix = self._filesuffix( signal_path )
        if suffix == &#34;npy&#34;: 
            signal = self._read_npy( signal_path )
        else: 
            signal = self._read_datafile( signal_path )

        # now save
        self.signal = signal

    # now the same for the events data file 
    if event_path is not None: 
        suffix = self._filesuffix( event_path )
        if suffix == &#34;npy&#34;: 
            events = self._read_npy( event_path )
        else: 
            events = self._read_datafile( event_path )

        # now save
        self.events = events</code></pre>
</details>
</dd>
<dt id="EEGToolkit.EEGData.EEGData.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self, x_scale:Â float, y_scale:Â float, significance_level:Â floatÂ =Â 0.05, output:Â strÂ =Â None, **kwargs) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Performs pair-wise T-Tests to compare extracted event data
(automatically extracts data for all events if no events were extracted yet).
Results are summarised in a figure. Individual signals are plotted
on the diagonal by their mean signal accross replicates with indicated SEM.
On non-diagonal plots pair-wise comparisons between two signals (one "horizontal"
and one "vertical" ) are shown. Regions of significant differences are shaded.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_scale</code></strong> :&ensp;<code>float</code></dt>
<dd>A scaling factor to adjust the data's x-value range.
E.g. <code>x_scale = 1000</code> to adjust the time-scale to milliseconds.</dd>
<dt><strong><code>y_scale</code></strong> :&ensp;<code>float</code></dt>
<dd>A scaling factor for the data's y-value range.
E.g. <code>y_scale = 1000</code> to adjust the signal-scale to millivolts.</dd>
<dt><strong><code>significance_level</code></strong> :&ensp;<code>float</code></dt>
<dd>The threshold for accepting a signal difference as significant.
Default is <code>0.05</code>.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>str</code></dt>
<dd>The output filename to save the summary figure into.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any additional keyword arguments to pass to <code><a title="EEGToolkit.EEGData.EEGData.extract" href="#EEGToolkit.EEGData.EEGData.extract">EEGData.extract()</a></code> in case
no event data has been extracted yet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self,
            x_scale:float,
            y_scale:float,
            significance_level:float = 0.05,
            output:str = None,
            **kwargs ) -&gt; None:
    &#34;&#34;&#34;
    Performs pair-wise T-Tests to compare extracted event data 
    (automatically extracts data for all events if no events were extracted yet). 
    Results are summarised in a figure. Individual signals are plotted
    on the diagonal by their mean signal accross replicates with indicated SEM.
    On non-diagonal plots pair-wise comparisons between two signals (one &#34;horizontal&#34;
    and one &#34;vertical&#34; ) are shown. Regions of significant differences are shaded.

    Parameters
    ----------

    x_scale : float
        A scaling factor to adjust the data&#39;s x-value range. 
        E.g. `x_scale = 1000` to adjust the time-scale to milliseconds.
    
    y_scale : float
        A scaling factor for the data&#39;s y-value range.
        E.g. `y_scale = 1000` to adjust the signal-scale to millivolts.

    significance_level : float
        The threshold for accepting a signal difference as significant.
        Default is `0.05`.
    
    output : str
        The output filename to save the summary figure into.

    **kwargs
        Any additional keyword arguments to pass to `EEGData.extract` in case
        no event data has been extracted yet.
    &#34;&#34;&#34;

    # extract the event data if not yet done already
    if self._data is None: 

        start_sec = kwargs.pop( &#34;start_sec&#34;, self._start_sec )
        stop_sec = kwargs.pop( &#34;stop_sec&#34;, self._stop_sec )
        self.extract( start_sec = start_sec, stop_sec = stop_sec, **kwargs )

    data = list( self._data ) 
    signals = list(self.n_events.keys())
    n = len(data)

    start_sec, stop_sec = self._start_sec, self._stop_sec

    # generate a new figure
    fig, ax = plt.subplots(n,n)

    # now first plot the individual signals
    # on their own on diagonal plots
    for i in range(n):

        # only the last subplot should make a legend
        make_legend = i == n-1 
        plot_signal(
                data[i], 
                self.sampling_frequency, 
                start_sec, stop_sec, 
                x_scale, y_scale,
                make_legend = make_legend,
                ax = ax[i,i] )
            
        ax[i,i].set_title(f&#34;Signal {signals[i]}&#34;)

        # hide all &#34;left-over&#34; subplots from the layout
        # i.e. hide the upper-right half of the figure...
        for a in ax[ i, i+1: ]:
            a.axis(&#34;off&#34;)

    # now make pair-wise comparisons between two signals
    # plotting the results on the lower-left half of the 
    # figure...
    for i,j in [(i,j) for i in range(n) for j in range(i)]:

        # only the last plot shall make a legend
        make_legend = i == n-1 and j == i-1 

        difference_plot( 
                            data[i], 
                            data[j], 
                            self.sampling_frequency, 
                            start_sec, stop_sec, 
                            significance_level, 
                            x_scale, y_scale,
                            make_legend = make_legend,
                            ax = ax[i,j]
                        )
        ax[i,j].set_title(f&#34;Signals: {signals[j]} vs {signals[i]}&#34;)

    fig.tight_layout()
    
    if output is None:
        plt.show()
        return fig
    plt.savefig(output, bbox_inches = &#34;tight&#34; )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#example-usage">Example Usage</a></li>
<li><a href="#cli">CLI</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EEGToolkit" href="index.html">EEGToolkit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="EEGToolkit.EEGData.main" href="#EEGToolkit.EEGData.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="EEGToolkit.EEGData.EEGData" href="#EEGToolkit.EEGData.EEGData">EEGData</a></code></h4>
<ul class="">
<li><code><a title="EEGToolkit.EEGData.EEGData.extract" href="#EEGToolkit.EEGData.EEGData.extract">extract</a></code></li>
<li><code><a title="EEGToolkit.EEGData.EEGData.read" href="#EEGToolkit.EEGData.EEGData.read">read</a></code></li>
<li><code><a title="EEGToolkit.EEGData.EEGData.summary" href="#EEGToolkit.EEGData.EEGData.summary">summary</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>